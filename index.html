<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arix Signature Tree - For WQC</title>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background-color: #001a14; }
        #canvas-container { width: 100vw; height: 100vh; }
        .instruction {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            color: #D4AF37;
            font-family: 'Times New Roman', serif;
            font-size: 14px;
            letter-spacing: 2px;
            opacity: 0.6;
            pointer-events: none;
            text-transform: uppercase;
            z-index: 10;
        }
        #loader {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #D4AF37;
            font-family: sans-serif;
            font-size: 1.2rem;
            z-index: 100;
            transition: opacity 0.5s ease;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "react": "https://esm.sh/react@18.2.0",
                "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
                "three": "https://esm.sh/three@0.160.0",
                "@react-three/fiber": "https://esm.sh/@react-three/fiber@8.15.12?external=react,react-dom,three",
                "@react-three/drei": "https://esm.sh/@react-three/drei@9.99.0?external=react,react-dom,three,@react-three/fiber"
            }
        }
    </script>
</head>
<body>
    <div id="loader">Loading Arix Signature Tree...</div>
    <div id="canvas-container"></div>
    <div class="instruction">Click / Tap to Interact</div>

    <script type="module">
        import React, { useState, useMemo, useRef, useEffect, Suspense } from 'react';
        import { createRoot } from 'react-dom/client';
        import * as THREE from 'three';
        import { Canvas, useFrame } from '@react-three/fiber';
        import { Text, OrbitControls, Environment, Float, Sparkles, Stars } from '@react-three/drei';

        // --- 1. CONFIGURATION ---
        const CONFIG = {
            count: 2000, 
            color: new THREE.Color("#FFD700"), 
            emissive: new THREE.Color("#FF8C00"),
            bgColor: "#001a14",
            treeHeight: 12,
            treeRadius: 4.5,
            scatterRadius: 25
        };

        // --- 2. UTILS: Native Math (Replacing External Libs) ---
        const randomInSphere = (radius) => {
            const u = Math.random();
            const v = Math.random();
            const theta = 2 * Math.PI * u;
            const phi = Math.acos(2 * v - 1);
            const r = radius * Math.cbrt(Math.random());
            return {
                x: r * Math.sin(phi) * Math.cos(theta),
                y: r * Math.sin(phi) * Math.sin(theta),
                z: r * Math.cos(phi)
            };
        };

        const generatePositions = (count) => {
            const treePositions = new Float32Array(count * 3);
            const scatterPositions = new Float32Array(count * 3);

            for (let i = 0; i < count; i++) {
                const i3 = i * 3;
                
                // Tree Shape
                const ratio = i / count;
                const y = THREE.MathUtils.lerp(CONFIG.treeHeight / 2, -CONFIG.treeHeight / 2, ratio);
                const radius = THREE.MathUtils.lerp(0, CONFIG.treeRadius, ratio);
                const angle = i * 2.4; 
                const randomOffset = Math.random() * 0.5;

                treePositions[i3] = Math.cos(angle) * (radius + randomOffset);
                treePositions[i3 + 1] = y;
                treePositions[i3 + 2] = Math.sin(angle) * (radius + randomOffset);

                // Scatter Shape
                const pos = randomInSphere(CONFIG.scatterRadius);
                scatterPositions[i3] = pos.x;
                scatterPositions[i3 + 1] = pos.y;
                scatterPositions[i3 + 2] = pos.z;
            }
            return { treePositions, scatterPositions };
        };

        // --- 3. COMPONENTS ---
        const JewelTree = ({ active }) => {
            const meshRef = useRef();
            const { treePositions, scatterPositions } = useMemo(() => generatePositions(CONFIG.count), []);
            const dummy = new THREE.Object3D();
            const tempPos = new THREE.Vector3();
            const animVal = useRef(0);

            useFrame((state, delta) => {
                if (!meshRef.current) return;

                const target = active ? 1 : 0;
                animVal.current = THREE.MathUtils.damp(animVal.current, target, 2.5, delta);
                const t = animVal.current; 

                for (let i = 0; i < CONFIG.count; i++) {
                    const i3 = i * 3;
                    const tx = treePositions[i3], ty = treePositions[i3+1], tz = treePositions[i3+2];
                    const sx = scatterPositions[i3], sy = scatterPositions[i3+1], sz = scatterPositions[i3+2];

                    tempPos.set(
                        THREE.MathUtils.lerp(sx, tx, t),
                        THREE.MathUtils.lerp(sy, ty, t),
                        THREE.MathUtils.lerp(sz, tz, t)
                    );

                    if (t > 0.8) {
                        const time = state.clock.elapsedTime;
                        tempPos.x += Math.cos(time + ty) * 0.05;
                        tempPos.z += Math.sin(time + ty) * 0.05;
                    }

                    dummy.position.copy(tempPos);
                    dummy.rotation.set(Math.sin(state.clock.elapsedTime * 0.2 + i), Math.cos(state.clock.elapsedTime * 0.3 + i), 0);
                    
                    const scale = 1 + (Math.sin(t * Math.PI) * 0.5); 
                    dummy.scale.setScalar(scale * (Math.random() * 0.5 + 0.5));

                    dummy.updateMatrix();
                    meshRef.current.setMatrixAt(i, dummy.matrix);
                }
                meshRef.current.instanceMatrix.needsUpdate = true;
            });

            return (
                <instancedMesh ref={meshRef} args={[null, null, CONFIG.count]}>
                    <octahedronGeometry args={[0.15, 0]} />
                    <meshPhysicalMaterial 
                        color={CONFIG.color}
                        emissive={CONFIG.emissive}
                        emissiveIntensity={2}
                        metalness={0.9}
                        roughness={0.1}
                    />
                </instancedMesh>
            );
        };

        const SignatureText = ({ active }) => {
            const groupRef = useRef();
            useFrame((state) => {
                if(groupRef.current) {
                    groupRef.current.position.y = -4 + Math.sin(state.clock.elapsedTime) * 0.2;
                    const targetScale = active ? 1 : 0.5;
                    groupRef.current.scale.lerp(new THREE.Vector3(targetScale, targetScale, targetScale), 0.1);
                }
            });

            return (
                <group ref={groupRef} position={[3.5, -4, 2]} rotation={[0, -0.3, 0]}>
                    <Float speed={2} rotationIntensity={0.2} floatIntensity={0.5}>
                        <Text
                            font="https://fonts.gstatic.com/s/playfairdisplay/v30/nuFvD-vYSZviVYUb_rj3ij__anPXJzDwcbmjWBN2PKdFvXDXbtM.woff"
                            fontSize={1.2}
                            letterSpacing={0.1}
                            textAlign="center"
                            anchorX="center"
                            anchorY="middle"
                        >
                            TO WQC
                            <meshStandardMaterial color="#ffffff" emissive="#FFD700" emissiveIntensity={0.8} />
                        </Text>
                    </Float>
                </group>
            );
        };

        const Scene = () => {
            const [active, setActive] = useState(false);
            useEffect(() => {
                const handleInteraction = () => setActive(prev => !prev);
                window.addEventListener('pointerdown', handleInteraction);
                return () => window.removeEventListener('pointerdown', handleInteraction);
            }, []);

            return (
                <>
                    <perspectiveCamera position={[0, 0, 15]} fov={45} />
                    <OrbitControls enablePan={false} enableZoom={false} minPolarAngle={Math.PI / 2.5} maxPolarAngle={Math.PI / 1.8} autoRotate autoRotateSpeed={active ? 1.0 : 0.5} />
                    
                    <ambientLight intensity={0.2} color="#004d33" />
                    <spotLight position={[10, 20, 10]} angle={0.3} penumbra={1} intensity={200} color="#ffebd6" />
                    <pointLight position={[-10, -10, -10]} intensity={50} color="#00ff99" />
                    
                    <Environment preset="city" />

                    <group position={[0, 1, 0]}>
                        <JewelTree active={active} />
                    </group>

                    <mesh position={[0, CONFIG.treeHeight / 2 + 1, 0]} scale={active ? 1 : 0}>
                         <octahedronGeometry args={[0.6, 0]} />
                         <meshBasicMaterial color="#FFF" />
                         <Sparkles count={20} scale={4} size={2} speed={0.4} color="#FFF" />
                    </mesh>

                    <Suspense fallback={null}>
                        <SignatureText active={active} />
                    </Suspense>

                    <Stars radius={100} depth={50} count={5000} factor={4} saturation={0} fade />
                    <Sparkles count={200} scale={12} size={2} speed={0.4} opacity={0.5} color="#D4AF37" />
                </>
            );
        };

        // --- 4. RENDER & LOADER HANDLING ---
        const rootElement = document.getElementById('canvas-container');
        const root = createRoot(rootElement);

        root.render(
            <Canvas
                gl={{ antialias: true, toneMapping: THREE.ACESFilmicToneMapping }}
                camera={{ position: [0, 0, 18], fov: 35 }}
                dpr={[1, 2]}
                onCreated={() => {
                    const loader = document.getElementById('loader');
                    if(loader) loader.style.opacity = '0';
                    setTimeout(() => loader?.remove(), 500);
                }}
            >
                <color attach="background" args={[CONFIG.bgColor]} />
                <fog attach="fog" args={[CONFIG.bgColor, 10, 40]} />
                <Scene />
            </Canvas>
        );
    </script>
</body>
</html>
